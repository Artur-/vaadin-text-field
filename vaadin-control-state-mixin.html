<script>
  window.Vaadin = window.Vaadin || {};

  // Polymer.IronControlState is not a proper 2.0 class, also, its tabindex
  // implementation fails in the shadow dom, so we have this for vaadin elements.
  Vaadin.ControlStateMixin = subclass => class VaadinControlStateMixin extends subclass {
    static get config() {
      var cfg = {
        properties: {
          /**
           * If true, the element currently has focus.
           */
          'focused': {
            type: Boolean,
            notify: true,
            readOnly: true,
            observer: 'focusedChanged',
            reflectToAttribute: true
          },

          /**
           * If true, the user cannot interact with this element.
           */
          'disabled': {
            type: Boolean,
            observer: '_disabledChanged',
            reflectToAttribute: true
          },

          /**
           * Internal property needed to listen to `tabindex` attribute changes.
           *
           * For changing the tabindex of this component use the native `tabIndex` propety.
           * @private
           */
          'tabindex': {
            type: Number,
            observer: '_tabindexChanged'
          }
        }
      };

      if (window.ShadyDOM) {
        // Edge needs these two properties defined because it messes up with upper/lower cased attributes.
        // Other ShadyDOM browsers need the `tabIndex` in order to notify when the user changes it programatically.
        cfg.properties['tab-index'] = cfg.properties['tabIndex'] = cfg.properties.tabindex;
      }

      return cfg;
    }

    ready() {
      super.ready();

      // In shadow dom, the element should be always focusable
      if (!this.disabled && this.getAttribute('tabindex') == null) {
        this._setTabindex(window.ShadyDOM ? -1 : 0);
      }

      this.addEventListener('focus', this._focus.bind(this));
      this.addEventListener('blur', () => this._setFocused(false));

      Polymer.RenderStatus.afterNextRender(this, () => {
        this.focusElement.addEventListener('focus', () => this._setFocused(true));
        this.focusElement.addEventListener('keydown', e => {
          if (e.shiftKey && e.keyCode === 9) {
            this.focus();
          }
        });

        // Make FF take the focus (#9)
        if (this.autofocus && !this.focused) {
          this.focus();
        }
      });
    }

    /**
     * Any element extending this mixin is required to implement this getter.
     * It returns the actual focusable element in the component.
     */
    get focusElement() {
      window.console.warn(`Please implement the 'focusElement' property in <${this.localName}>`);
      return this;
    }

    _focus() {
      this.focusElement.focus();
    }

    // Native bluring in the host element does nothing because it does not have the focus.
    // In chrome it works, but not in FF.
    blur() {
      this.focusElement.blur();
    }

    _disabledChanged(disabled) {
      this.focusElement.disabled = disabled;
      if (disabled) {
        this._setFocused(false);
        this.blur();
        this._setTabindex(undefined);
      } else {
        this._setTabindex(window.ShadyDOM ? -1 : this.focusElement.tabIndex);
      }
    }

    _tabindexChanged(tabindex) {
      if (!this._tabindexLocked) {
        this.focusElement.tabIndex = tabindex;
        if (this.disabled) {
          this._setTabindex(undefined);
        } else if (window.ShadyDOM) {
          this._setTabindex(-1);
        }
      }
    }

    _setTabindex(tabindex) {
      this._tabindexLocked = true;
      if (tabindex === undefined) {
        this.removeAttribute('tabindex');
      } else {
        this.setAttribute('tabindex', tabindex);
      }
      delete this._tabindexLocked;
    }

    focusedChanged() {
      // Needed for Edge, until they have support for CSS Custom Properties
      // (already shipping in Edge Preview)
      this.updateStyles();
    }
  };
</script>
